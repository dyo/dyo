<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>DIO – API</title>
	<link rel=stylesheet href=css/stylesheet.css>
	<link rel=icon type=image/png href=../imgs/favicon-large.png sizes=32x32>
	<link rel=icon type=image/png href=../imgs/favicon-small.png sizes=16x16>
</head>
<body>
	<a href=./ title=index class=logo>
		<img src=imgs/logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=./>Index</a>
			<a href=./introduction.html>Introduction</a>
			<a href=./api.html>API</a>
			<a href=./examples.html>Examples</a>
			<a href=https://github.com/thysultan/dio.js>GitHub</a>
		</nav>
	</header>
	<article>
		<h1>API</h1>

		<p>
			DIO's API surface is small to a benefit, <br>with a close resemblance to React.
		</p>

		<h1 id=elements>Elements</h1>

		<p>Elements are made up of three parts</p>

		<ol>
			<li>type &mdash; type of element that should be rendered.</li>
			<li>props &mdash; properties associated with the element.</li>
			<li>children &mdash; children contained within the element</li>
		</ol>

<pre><code>
const h1 = h('h1', {
	class: 'heading'
}, 'Hello World')
</code></pre>

		<h2 id=clone>cloneElement</h2>

		<p>
			When the first argument of an element, its type, is a virtual element, the element is cloned with new children replacing old children and props shallow merged.
		</p>

<pre><code>
const h1 = h('h1', {
	class: 'large'
}, 'Hello World')

const h2 = dio.cloneElement(h1, {
	class: 'small'
}, 'The Fox')
</code></pre>

		<h2 id=portals>Portals</h2>

		<p>
			A portal is created when the first argument of an element, its type, is a DOM node.
		</p>

<pre><code>
dio.render(h('div', 1, h(document.body, 2, 3)))
</code></pre>

		<h1 id=components>Components</h1>

		<p>
			Components are either of a Class or Function.
		</p>

		<h2>Classes</h2>

<pre><code>
class Welcome {
	render() {
		return 'Welcome'
	}
}
</code></pre>

<pre><code>
class Welcome extends dio.Component {
	render() {
		return 'Welcome'
	}
}
</code></pre>

		<h2>Functions</h2>
<pre><code>
const Welcome = () => {
	return 'Welcome'
}

function Welcome () {
	return 'Welcome'
}
</code></pre>
	
		<p>All components <code>this</code> references the components instance, including function components.</p>

		<h1 id=lifecycle>Lifecycle</h1>

		<p>
			Both <code>function</code> and <code>class</code> are state-full and can make use of lifecycles and state.
		</p>

		<h2>Data</h2>

		<p>
			The lifecycle method <code>getInitialState</code> can be used to assigns an initial state, while on the other hand
			<code>getChildContext</code> can be used to declare context that cascades to the components children.
		</p>

<pre><code>
class Welcome {
	getInitialState() {
		return {id: 1}
	}
	getChildContext() {
		return {age: 24}
	}
	render() {}
}
</code></pre>

		<h2 id=props>Events</h2>
		
		<p>
			All events in DIO are prefixed with <code>on</code> and case insensitve making both <code>onClick</code> and <code>onclick</code> equivalent.
		</p>

<pre><code>
class Welcome {
	handleClick() {}
	render() {
		return h('button', {onClick: this.handleClick})
	}
}
</code></pre>
		

		<p>The value of an event property is either a <code>function</code> type or, an <a href=https://developer.mozilla.org/en/docs/Web/API/EventListener>EventListener</a>, that is to say any object that defines a <code>handleEvent</code> method.</p>

<pre><code>
{
	handleEvent() {}
}
</code></pre>

		<p>
			When assigning events, the reconciler will always have prior knownledge of host component that an element stems from. This allows us to attach events as they are and guarantee that references to <code>this</code> always point to the host components instance.
		</p>

<pre><code>
class Welcome {
	handleClick() {
		this instanceof Welcome
	}
	render() {
		return h('button', {onClick: this.handleClick})
	}
}
</code></pre>

		<h2>dangerouslySetInnerHTML</h2>

		<p>dangerouslySetInnerHTML is a special propery that can be used to set the <code>innerHTML</code> of elements.</p>

<pre><code>
class Welcome {
	render() {
		return h('div', {
			dangerouslySetInnerHTML: {__html: '<h1>Welcome</h1>'}
		})
	}
}
</code></pre>

		<h2 id=refs>Refs</h2>

		<p>
			A Ref is either a function or a string that provides access to the underlining native View node or component instance.
		</p>

<pre><code>
class Welcome {
	getBoundingClientRect(node) {
		node.getBoundingClientRect()
	}
	render() {
		return h('h1', {
			ref: this.getBoundingClientRect
		}, 'Welcome')
	}
}
</code></pre>

		<h2 id=mounting>Mounting</h2>

		<p>
			Mounting happens in a bottom-up fashion in that the lifecycle method of child components will be invoked before the parent.
		</p>

		<p>
			The lifecycle method <code>componentDidMount</code> receives the mounting native View node as an argument.
		</p>

<pre><code>
class Welcome {
	componentWillMount() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentDidMount() {}
}
</code></pre>

		<h2 id=updating>Updating</h2>

		<p>
			Certain lifecycles are only invoked in the update phase; When an update is triggerd through <code>this.setState</code> or <code>this.forceUpdate</code>, the lifecycle method <code>componentWillReceiveProps</code> will not be invoked because new props are not received.
		</p>

		<p>
			On the other hand if <code>shouldComponentUpdate</code> returns <code>false</code> then that would halt a components update phase.
		</p>

<pre><code>
class Welcome {
	componentWillReceiveProps() {}
}
</code></pre>

<pre><code>
class Welcome {
	shouldComponentUpdate() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentWillUpdate() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentDidUpdate() {}
}
</code></pre>

		<h2 id=unmounting>Umounting</h2>

		<p>
			When/if the <code>componentWillUnmount</code> lifecycle method return a <code>Promise</code> the unmounting native View node will be removed only once the <code>Promise</code> has resolved.
		</p>

		<p>
			Like <code>componentDidMount</code>, <code>componentWillUnmount</code> also receives the unmounting native View node as an argument.
		</p>

<pre><code>
class Welcome {
	componentWillUnmount() {}
}
</code></pre>

		<h1 id=setstate>setState</h1>

		<p>
			A component can update its state by invoking <code>this.setState</code> with an Object representing how to update the state or a <code>Promise</code> that resolves to an with the same purpose.
		</p>

		<p>
			In addition to the explicit <code>this.setState</code> API, a component can return an Object value to update the state.
		</p>

		<h2>Data</h2>

<pre><code>
class Welcome {
	getInitialState() {
		return {n: 0}
	}
}
</code></pre>

		<h2>Lifecycle</h2>

<pre><code>
class Welcome {
	componentDidMount() {
		return {n: 0}
	}
}
</code></pre>

		<h2>Event</h2>

<pre><code>
class Welcome {
	handleClick() {
		return {n: 0}
	}
	render() {
		h('button', {
			onclick: this.handleClick
		}, 'Click Me')
	}
}
</code></pre>

		<h2>Async</h2>

<pre><code>
class Welcome {
	async getInitialState() {
		return {n: 0}
	}
}
</code></pre>

		<h1 id=forceupdate>forceUpdate</h1>

		<p>When invoked, dispatches an update skipping <code>shouldComponentUpdate</code>.</p>

		<h1 id=render>Render</h1>

		<p>
			The first argument is the element you want to render, the second the native container View node you want to render to, the third argument is an optional callback.
		</p>

<pre><code>
dio.render('Hello World', document.documentElement)
</code></pre>

		<p>
			When ommitted the second argument defaults to the top-level <code>&lt;html></code> DOM node.
		</p>

		<pre><code>
		dio.render('Hello World')
		</code></pre>

		<h2 id=server>Server</h2>

		<p>
			The recommended way to render from the server is to use either <code>dio.renderToStream</code> or <code>dio.renderToString</code> which can both also render to a Writable Stream.
		</p>

<pre><code>
const http = require('http')
const dio = require('dio.js')

const webpage = [
	h('!doctype'),
	h('head',
		h('title', 'Title!'),
		h('style', `h1 {color:red;}`),
		h('script', `console.log("Hello")`)
	),
	h('body', 'Hello World')
]

const server = (request, response) => {
	dio.renderToStream(webpage, response)
}

http.createServer(server).listen(2000)
</code></pre>

		<p>
			<code>dio.renderToStream</code> uses a readable Stream to send the asynchronous payload in chunks to the writable stream. On the other hand <code>dio.renderToString</code> and the <code>Element#toString</code> are synchronous operations.
		</p>

<pre><code>
dio.renderToString(h('html')) === `&lt;html>&lt;/html>`
`${h('html')}` === `&lt;html>&lt;/html>`
</code></pre>

		<h2 id=testing>toJSON</h2>

		<p>
			Like <code>toString</code> all elements on the server have a <code>toJSON</code> method that returns a flat element representation.
		</p>

<pre><code>
h('html').toJSON()
</code></pre>

		<h1 id=version>Version</h1>

		<p>
			Stores the current version of DIO in use, for example. <code>8.0.0</code>
		</p>

<pre><code>
console.log(dio.version)
</code></pre>

		<h2 id=error-boundaries>Error Boundary</h2>

		<p>
			All components have a default error boundary that cascades to the nearest parent component if the component does not define a <code>componentDidCatch</code> method.
		</p>
<pre><code>
class Welcome {
	componentDidThrow({from, message, children, stack}) {
		if (from === 'render')
			return h('h1', 'Error State for render Error')
		else
			return h('h1', 'Error State for another Error')
	}
	render () {
		throw ''
	}
}
</code></pre>

		<p>Consider the error happened in the update phase, and we avoid handling the error. In this case the error boundary would simply resolve to the nearest parent component that defines <code>componentDidCatch</code>, if there does not exist a component in the render tree that defines a <code>componentDidCatch</code> error state, all components from the root down will unmount.</p>

		<h2 id=non-deterministic>Non-Deterministic</h2>

		<p>
			By default rendering something is a <a href=https://en.wikipedia.org/wiki/Deterministic_system>deterministic</a> <label></label><span class=note>A deterministic system is a system in which no randomness is involved in the development of future states of the system.</span> operation,
			given the following children <code>`[A, B, C, D]`</code> the path the flow would take would be.
		</p>

		<p class=math>A &#x2192; B &#x2192; C &#x2192; D</p>

		<p>
			But <a href=https://en.wikipedia.org/wiki/Nondeterministic_algorithm>non-deterministic</a> <label></label>
			<span class=note>A non-deterministic algorithm is an algorithm that, even for the same input, can exhibit different behaviors on different runs.</span>
			introduces the aspect of non-linear updates, where instead of <code>`A &#x2192; B &#x2192; C &#x2192; D`</code> you could get an array of different update sequences;
		</p>

		<p>For example:</p>

		<p class=math>C &#x2192; D &#x2192; A &#x2192; B</p>

		<p>This is possible because DIO can render Promises.</p>

		<p>In the example that follows we wait for a random time before resolving the return value of a render.</p>

<pre><code>
class Welcome {
	render() {
		return new Promise((resolve) => {
			setTimeout(() => {
				resolve(
					h('h1',
						'performance now - ',
						performance.now()
					)
				)
			}, Math.random()*1000)
		})
	}
}
</code></pre>

		<p>Putting multiple instances of this component in a list will result in a random update order whenever an update is invoked.</p>

		<h2 id=coroutine>Iterables</h2>

		<p>Both <code>Iterables</code> and <code>Generators</code> are supported as render elements.</p>

<pre><code>
class Welcome {
	*render(props) {
		let supply = 0

		while (supply < 10) {
			yield h('button', {
				onclick: this.forceUpdate
			}, 'Click Me - ', supply++)
		}
	}
}
</code></pre>

		<h2 id=animations>Animations</h2>

		<p>There is no specialized API for animations in DIO, however the mount/unmount lifecycles methods have been designed with animations in mind.</p>

		<p>Making use of the <code>componentWillUnmount</code> lifecycle return signature and <code>componentDidMount</code> we can animate any components mount and unmount cycles;</p>

		<p>As an example, using the experimental <a href=https://developer.mozilla.org/en-US/docs/Web/API/Element/animate>Element.animate</a><label></label><span class=note>The Web Animations API opens the browser’s animation engine to developers and manipulation by JavaScript. This API was designed to underlie implementations of both CSS Animations and CSS Transitions, and leaves the door open to future animation effects. It is one of the most performant ways to animate on the Web where supported, letting the browser make its own internal optimizations without hacks, coercion, or Window.requestAnimationFrame(). <a href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Using_the_Web_Animations_API>Using the Web Animations API.</a></span> API:</p>

<pre><code>
const animations = {
	fadeOut: [
	  {transform: 'translateY(0)', opacity: 1},
  	{transform: 'translateY(-100%)', opacity: 0}
  ],
  fadeIn: [
	  {transform: 'translateY(-100%)', opacity: 0},
  	{transform: 'translateY(0%)', opacity: 1}
  ]
}

class Item {
	componentDidMount(node) {
		node.animate(animations.fadeIn, {
			duration: 200
		});
	}
	componentWillUnmount(node) {
		return new Promise((resolve) => {
			node.animate(animations.fadeOut, {
				duration: 200
			}).onfinish = resolve
		})
	}
	render() {
		return h('li', this.props.children)
	}
}

class List {
	render() {
		return h('ul', this.props.children.map(
			v => h(List, v)
		))
	}
}

dio.render(h(List, 1, 2, 3))

setTimeout(dio.render, 400, h(List, 1, 2, 3, 4))
setTimeout(dio.render, 800, h(List, 1, 2, 3))
</code></pre>

		<h2 id=promises>Promises</h2>

		<p>In large applications, bundles might become too big to send to the client in one chunk, this suggests the need to divide the app into smaller chunks and only load a component from the server when it is actually needed.</p>

		<p>To make this task easier components are allowed a <code>Promise</code> return type that you can be used to control when a component renders.

		<p>
			However at the same time when talking about async operations we have to consider what we want to display while we wait for the network to resolve
		</p>

<pre><code>
class Welcome {
	render() {
		return h(import('./welcome.js'), h('h1', 'Loading'))
	}
}		
</code></pre>

		<p>When the children of a <code>Promise</code> element are specified the reconciler renders these children for the time it takes for the promise to resolve.</p>

		<h1 id=Children>Children</h2>

		<p>Because <code>this.props.children</code> is an opaque data-strucuture utilities are provided to help to normalize working with this where needed.</p>
			
		<h2>Children.map</h2>

<pre><code>
dio.Children.map(this.props.children, ()=>{}, thisArg)	
</code></pre>

		<h2>Children.forEach</h2>

<pre><code>
dio.Children.forEach(this.props.children, ()=>{}, thisArg)		
</code></pre>

		<h2>Children.toArray</h2>

<pre><code>
dio.Children.toArray(this.props.children)		
</code></pre>

		<h2>Children.count</h2>

<pre><code>
dio.Children.count(this.props.children)		
</code></pre>

		<h2>Children.only</h2>

<pre><code>
dio.Children.only(this.props.children)		
</code></pre>

		<h1 id=other>Other</h2>
		
		<h2>isValidElement</h2>

<pre><code>
dio.isValidElement(h('h1'))	
</code></pre>

		<h2>findDOMNode</h2>

<pre><code>
dio.findDOMNode(this)	
</code></pre>

		<h1 id=other>Statics</h1>

		<h2 id=statics>Static defaultProps</h2>

		<p>
			The following would resemble attaching the returned object of the functions to the <code>Welcome</code>.
		</p>

<pre><code>
class Welcome {
	static defaultProps () {
		return {id: 1}
	}
	render () {}
}
</code></pre>

		<p>Would be identical to the following:</p>

<pre><code>
class Welcome {
	render () {}
}
Welcome.defaultProps = {id: 1}
</code></pre>

	</article>
	<script src=js/highlight.js></script>
	<script src=js/main.js></script>
</body>
</html>
