<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>DIO – API</title>
	<link rel=stylesheet href=css/stylesheet.css>
	<link rel=icon type=image/png href=../imgs/favicon-large.png sizes=32x32>
	<link rel=icon type=image/png href=../imgs/favicon-small.png sizes=16x16>
</head>
<body>
	<a href=./ title=index class=logo>
		<img src=imgs/logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=./>Index</a>
			<a href=./introduction.html>Introduction</a>
			<a href=./api.html>API</a>
			<a href=./examples.html>Examples</a>
			<a href=https://github.com/thysultan/dio.js>GitHub</a>
		</nav>
	</header>
	<article>
		<h1>API</h1>

		<p>
			DIO's API surface is small to a benefit, <br>with a close resemblance to React.
		</p>

		<h1 id=elements>Elements</h1>

		<p>Elements are made up of three parts</p>

		<ol>
			<li>type &mdash; type of element that should be rendered.</li>
			<li>props &mdash; properties associated the element.</li>
			<li>children &mdash; children contained within the element</li>
		</ol>

<pre><code>
const h1 = h('h1', {
	class: 'heading'
}, 'Hello World')
</code></pre>

		<h2 id=clone>cloneElement</h2>

		<p>
			When the first argument of an element, its type, is a virtual element, the element is cloned with new children replacing old children and props shallow merged.
		</p>

<pre><code>
const h1 = h('h1', {
	class: 'large'
}, 'Hello World')

const h2 = h(h1, {
	class: 'small'
}, 'The Fox')
</code></pre>

		<p>
			This is also how the <code>`dio.cloneElement`</code> API works.
		</p>

		<h2 id=portals>Portals</h2>

		<p>
			A portal is created when the first argument of an element: its type, is a DOM node.
		</p>

<pre><code>
dio.render(h('div', 1, h(document.body, 2, 3)))
</code></pre>

		<h1 id=components>Components</h1>

		<p>
			Components are either a Classes or Functions.
		</p>

		<h2>Classes</h2>

<pre><code>
class Welcome {
	render() {
		return 'Welcome'
	}
}
</code></pre>

<pre><code>
class Welcome extends dio.Component {
	render() {
		return 'Welcome'
	}
}
</code></pre>

		<h2>Functions</h2>
<pre><code>
const Welcome = () => {
	return 'Welcome'
}

function Welcome () {
	return 'Welcome'
}
</code></pre>


		<h1 id=lifecycle>Lifecycle</h1>

		<p>
			Both <code>function</code> and <code>class</code> are state-full and can make full use of lifecycles.
		</p>

		<h2>Data</h2>

		<p>
			<code>getInitialState</code> assigns initial state, on the other hand
			<code>getChildContext</code> is used to declare context that cascades the components children.
		</p>

<pre><code>
class Welcome {
	getInitialState() {
		return {id: 1}
	}
	getChildContext() {
		return {age: 24}
	}
	render() {}
}
</code></pre>

		<h2 id=refs>Refs</h2>

		<p>
			A Ref is either a function or a string that provides access to the underlining native DOM node or component instance.
		</p>

<pre><code>
class Welcome {
	getBoundingClientRect(node) {
		node.getBoundingClientRect()
	}
	render() {
		return h('h1', {
			ref: this.getBoundingClientRect
		}, 'Welcome')
	}
}
</code></pre>

		<h2 id=mounting>Mounting</h2>

		<p>
			Mounting happens in a bottom-up fashion in that the lifecycle method of child components will be invoked before the parent.
		</p>

		<p>
			The lifecycle method <code>componentDidMount</code> receives the mounting native DOM node as an argument.
		</p>

<pre><code>
class Welcome {
	componentWillMount() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentDidMount() {}
}
</code></pre>

		<h2 id=updating>Updating</h2>

		<p>
			Certain lifecycles are only invoked in the update phase; When an update is triggerd through <code>this.setState</code> or <code>this.forceUpdate</code>, the <code>componentWillReceiveProps</code> lifecycle will not be invoked because new props are not received.
		</p>

		<p>
			On the other hand if <code>shouldComponentUpdate</code> returns <code>false</code> then that would halt a components update phase.
		</p>

<pre><code>
class Welcome {
	componentWillReceiveProps() {}
}
</code></pre>

<pre><code>
class Welcome {
	shouldComponentUpdate() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentWillUpdate() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentDidUpdate() {}
}
</code></pre>

		<h2 id=unmounting>Umounting</h2>

		<p>
			Unlike mounting unmounting happens in a top-down fashion.
		</p>

		<p>
			If the <code>componentWillUnmount</code> method return a <code>Promise</code> the unmounting native DOM node will be removed only once the <code>Promise</code> has resolved.
		</p>

		<p>
			Like <code>componentDidMount</code>, <code>componentWillUnmount</code> also receives the unmounting native DOM node as an argument.
		</p>

<pre><code>
class Welcome {
	componentWillUnmount() {}
}
</code></pre>

		<h1 id=setstate>setState</h1>

		<p>
			A component can update its state by invoking <code>this.setState</code> with an Object representing how to update the state or a <code>Promise</code> that resolves to an Object.
		</p>

		<p>
			In addition to explicit <code>this.setState</code> API, DIO supports an implicit Object return value to update the state.
		</p>

		<h2>Data</h2>

<pre><code>
class Welcome {
	getInitialState() {
		return {n: 0}
	}
}
</code></pre>

		<h2>Lifecycle</h2>

<pre><code>
class Welcome {
	componentDidMount() {
		return {n: 0}
	}
}
</code></pre>

		<h2>Event</h2>

<pre><code>
class Welcome {
	handleClick() {
		return {n: 0}
	}
	render() {
		h('button', {
			onclick: this.handleClick
		}, 'Click Me')
	}
}
</code></pre>

		<h2>Async</h2>

<pre><code>
class Welcome {
	async getInitialState() {
		return {n: 0}
	}
}
</code></pre>

		<h1 id=setstate>forceUpdate</h1>

		<p>Used when you want to invoke an update without a state update.</p>

		<h1 id=render>Render</h1>

		<p>
			The first argument is the element <label for=1></label>
			<span class=note>This includes strings, numbers, functions, null, arrays, etc.</span>
			you want to render, the second is the native container DOM node you want render to and the third argument is an optional callback.
		</p>

<pre><code>
dio.render('Hello World', document.documentElement)
</code></pre>

		<p>
			When ommitted the second argument defaults to the top-level <code>`&lt;html>`</code> DOM node.
		</p>

		<pre><code>
		dio.render('Hello World')
		</code></pre>

		<h2 id=server>Server</h2>

		<p>
			The recommended way to render from the server is to use either <code>dio.renderToStream</code> or <code>dio.renderToString</code> which can both also render to a Writable Stream.
		</p>

<pre><code>
const http = require('http')
const dio = require('dio.js')

const webpage = [
	h('!doctype'),
	h('head',
		h('title', 'Title!'),
		h('style', `h1 {color:red;}`),
		h('script', `console.log("Hello")`)
	),
	h('body', 'Hello World')
]

const server = (request, response) => {
	dio.renderToStream(webpage, response)
}

http.createServer(server).listen(2000)
</code></pre>

		<p>
			<code>dio.renderToStream</code> uses a Readable Stream to send the asynchronous payload in chunks to the Writable Stream, while on the other hand <code>dio.renderToString</code> and the <code>Element#toString</code> are synchronous operations.
		</p>

<pre><code>
dio.renderToString(h('html')) === `${h('html')}` === `&lt;html>&lt;/html>`
</code></pre>

		<h2 id=testing>toJSON</h2>

		<p>
			All elements on the server have a `toJSON` method that returns a flat element representation that could be used for testing purposes.
		</p>

<pre><code>
h('html').toJSON()
</code></pre>

		<h1 id=version>Version</h1>

		<p>
			Stores the current version of DIO in use, for example. <code>8.0.0</code>
		</p>

<pre><code>
console.log(dio.version)
</code></pre>

		<h2 id=error-boundaries>Error Boundary</h2>

		<p>
			All components have a default error boundary that cascades to the nearest parent component if the component does not define a <code>componentDidCatch</code> method.
		</p>
<pre><code>
class Welcome {
	componentDidThrow({from, message, children, stack}) {
		if (from === 'render')
			return h('h1', 'Error State for render Error')
		else
			return h('h1', 'Error State for another Error')
	}
	render () {
		throw ''
	}
}
</code></pre>

		<p>If the error happened in the update phase and we did not handle it, DIO would simply resolve to the nearest parent component that defines <code>componentDidCatch</code>, if there does not exist a component in the render tree that defines a <code>componentDidCatch</code> error state, DIO will unmount all component from the root.</p>

		<h2 id=non-deterministic>Non-Deterministic</h2>

		<p>
			By default rendering something is a <a href=https://en.wikipedia.org/wiki/Deterministic_system>deterministic</a> <label for=2></label><span class=note>A deterministic system is a system in which no randomness is involved in the development of future states of the system.</span> operation,
			given the following children <code>`[A, B, C, D]`</code> the path the flow would take would be.
		</p>

		<p class=math>A &#x2192; B &#x2192; C &#x2192; D</p>

		<p>
			But <a href=https://en.wikipedia.org/wiki/Nondeterministic_algorithm>non-deterministic</a> <label for=3></label>
			<span class=note>A non-deterministic algorithm is an algorithm that, even for the same input, can exhibit different behaviors on different runs.</span>
			introduces the aspect of non-linear updates, where instead of <code>`A &#x2192; B &#x2192; C &#x2192; D`</code> you could get an array of different update sequences;
		</p>

		<p>For example:</p>

		<p class=math>C &#x2192; D &#x2192; A &#x2192; B</p>

		<p>This is possible because DIO can render Promises.</p>

		<p>In the example that follows we wait for a random time before resolving the return value of a render.</p>

<pre><code>
class Welcome {
	render() {
		return new Promise((resolve) => {
			setTimeout(() => {
				resolve(
					h('h1',
						'performance now - ',
						performance.now()
					)
				)
			}, Math.random()*1000)
		})
	}
}
</code></pre>

		<p>Putting multiple instances of this component in a list will result in a random update order whenever an update is invoked.</p>

		<h2 id=coroutine>Iterables</h2>

		<p>DIO supports rendering any <code>Iterables</code> including <code>Generators</code>.</p>

<pre><code>
class Welcome {
	*render(props) {
		let supply = 0

		while (supply < 10) {
			yield h('button', {
				onclick: this.forceUpdate
			}, 'Click Me - ', supply++)
		}
	}
}
</code></pre>

		<h2 id=animations>Animations</h2>

		<p>There is no specialized API for animations in DIO, however the mount/unmount lifecycles methods have been designed with animations in mind.</p>

		<p>Making use of the <code>componentWillUnmount</code> lifecycle return signature and <code>componentDidMount</code> we can animate any components mount and unmount cycles;</p>

		<p>As an example, using the new <a href=https://developer.mozilla.org/en-US/docs/Web/API/Element/animate>Element.animate</a><label for=4></label><span class=note>The Web Animations API opens the browser’s animation engine to developers and manipulation by JavaScript. This API was designed to underlie implementations of both CSS Animations and CSS Transitions, and leaves the door open to future animation effects. It is one of the most performant ways to animate on the Web where supported, letting the browser make its own internal optimizations without hacks, coercion, or Window.requestAnimationFrame(). <a href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Using_the_Web_Animations_API>Using the Web Animations API.</a></span> API:</p>

<pre><code>
const animations = {
	fadeOut: [
	  {transform: 'translateY(0)', opacity: 1},
  	{transform: 'translateY(-100%)', opacity: 0}
  ],
  fadeIn: [
	  {transform: 'translateY(-100%)', opacity: 0},
  	{transform: 'translateY(0%)', opacity: 1}
  ]
}

class Item {
	componentDidMount(node) {
		node.animate(animations.fadeIn, {
			duration: 200
		});
	}
	componentWillUnmount(node) {
		return new Promise((resolve) => {
			node.animate(animations.fadeOut, {
				duration: 200
			}).onfinish = resolve
		})
	}
	render() {
		return h('li', this.props.children)
	}
}

class List {
	render() {
		return h('ul', this.props.children.map(
			v => h(List, v)
		))
	}
}

dio.render(h(List, 1, 2, 3))

setTimeout(dio.render, 400, h(List, 1, 2, 3, 4))
setTimeout(dio.render, 800, h(List, 1, 2, 3))
</code></pre>

		<h2 id=promises>Promises</h2>

		<p>In large applications, bundles might become too big to send to the client in one chunk, this suggests the need to divide the app into smaller chunks and only load a component from the server when it is actually needed.</p>

		<p>To make this task easier DIO allows a <code>Promise</code> return type from Components that you can use to control when a component renders, essentially baking the  
		<a href="https://en.wikipedia.org/wiki/Lazy_loading">"Lazy loading"</a><label for=5></label><span class="note">Lazy loading is a design pattern commonly used in computer programming to defer initialization of an object until the point at which it is needed. It can contribute to efficiency in the program's operation if properly and appropriately used.</span> design pattern into the component model.
		</p>

		<p>
			However when talking about lazy loading, we have to consider what we want to display while we wait for the network to resolve, for this specific reason DIO also supports optional children what define what element/component will render while waiting for the network.
		</p>

<pre><code>
class Welcome {
	render() {
		return h(import('./welcome.js'), h('h1', 'Loading'))
	}
}		
</code></pre>

		<p>This allows us to lazy load components when we need them and what to display before the requested module has been resolved.</p>

		<h1 id=Children>Children</h2>

		<p>Because <code>this.props.children</code> is an opaque data-strucuture DIO provides utility functions to normalize working with the opaque data-strucuture when needed.</p>
			
		<h2>Children.map</h2>

<pre><code>
dio.Children.map(this.props.children, ()=>{}, thisArg)	
</code></pre>

		<h2>Children.forEach</h2>

<pre><code>
dio.Children.forEach(this.props.children, ()=>{}, thisArg)		
</code></pre>

		<h2>Children.toArray</h2>

<pre><code>
dio.Children.toArray(this.props.children)		
</code></pre>

		<h2>Children.count</h2>

<pre><code>
dio.Children.count(this.props.children)		
</code></pre>

		<h2>Children.only</h2>

<pre><code>
dio.Children.only(this.props.children)		
</code></pre>

		<h1 id=other>Other</h2>
		
		<h2>isValidElement</h2>

<pre><code>
dio.isValidElement(h('h1'))	
</code></pre>

		<h2>findDOMNode</h2>

<pre><code>
dio.findDOMNode(this)	
</code></pre>

		<h1 id=other>Statics</h1>

		<h2 id=statics>Static defaultProps</h2>

		<p>
			The following would resemble attaching the returned object of the functions to the <code>Welcome</code>.
		</p>

<pre><code>
class Welcome {
	static defaultProps () {
		return {id: 1}
	}
	render () {}
}
</code></pre>

		<p>Would be identical to the following:</p>

<pre><code>
class Welcome {
	render () {}
}
Welcome.defaultProps = {id: 1}
</code></pre>

	</article>
	<script src=js/highlight.js></script>
	<script src=js/main.js></script>
</body>
</html>
