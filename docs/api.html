<!DOCTYPE html>
<html>
<head>
	<meta charset=utf-8>
	<meta http-equiv=X-UA-Compatible content=IE=edge>
	<meta name=viewport content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
	<title>DIO – API</title>
	<link rel=stylesheet href=css/stylesheet.css>
	<link rel=icon type=image/png href=../imgs/favicon-large.png sizes=32x32>
	<link rel=icon type=image/png href=../imgs/favicon-small.png sizes=16x16>
</head>
<body>
	<a href=./ title=index class=logo>
		<img src=imgs/logo.svg alt=logo>
	</a>
	<header>
		<nav>
			<a href=./>Index</a>
			<a href=./introduction.html>Introduction</a>
			<a href=./api.html>API</a>
			<a href=./examples.html>Examples</a>
			<a href=https://github.com/thysultan/dio.js>GitHub</a>
		</nav>
	</header>
	<article>
		<h1>API</h1>

		<p>
			DIO's API surface is small to a benefit, <br>with a close resemblance to React.
		</p>

		<h1 id=elements>Elements</h1>

		<p>Elements are made up of three parts</p>

		<ol>
			<li>type &mdash; type of element that should be rendered.</li>
			<li>props &mdash; properties associated the element.</li>
			<li>children &mdash; children contained within the element</li>
		</ol>

<pre><code>
const h1 = h('h1', {
	class: 'heading'
}, 'Hello World')
</code></pre>

		<h2 id=clone>cloneElement</h2>

		<p>When the first argument of an element, its type, is a virtual element, the element is cloned with new children replacing old children and props shallow merged.</p>

<pre><code>
const h1 = h('h1', {
	class: 'large'
}, 'Hello World')

const h2 = h(h1, {
	class: 'small'
}, 'The Fox')
</code></pre>

		<h2 id=portals>Portals</h2>

		<p>A portal is created when the first argument of an element, its type, is a DOM node. This means that when the element is mounted the children of the portal will be placed in the DOM node specified regardless of what its virtual parent is in the tree of virtual elements.</p>

		<p>Given the following:</p>

<pre><code>
const portal = h(document.body, 2, 3)

dio.render(h('div', 1, portal))
</code></pre>

		<p>We would find 1 to be in its parent <code>`div`</code> while 2 &amp; 3 would be placed into <code>`document.body`.</code></p>

		<h1 id=components>Components</h1>

		<p>
			Components can be either a <code>class</code> or a <code>function</code>, and though the class syntax can extend <code>dio.Component</code> DIO accepts plain classes alike.
		</p>

		<h2>Classes</h2>

<pre><code>
class Welcome {
	render() {
		return 'Welcome';
	}
}
</code></pre>

<pre><code>
class Welcome extends dio.Component {
	render() {
		return 'Welcome'
	}
}
</code></pre>

<pre><code>
function Welcome {}
Welcome.prototype = {
	render() {
		return 'Welcome'
	}
}
</code></pre>

		<h2>Functions</h2>
<pre><code>
const Welcome = () => {
	return 'Welcome'
}

function Welcome () {
	return 'Welcome'
}
</code></pre>

<pre><code>
function* Welcome () {
	return 'Welcome'
}
</code></pre>

		<h1 id=lifecycle>Lifecycle</h1>

		<p>
			Both <code>function</code> and <code>class</code> components can make use of lifcycles <label for=1></label>.
		</p>

		<p>When required any lifecycle on a component can call <code>`this.setState`</code> or return a state update object to update the state.</p>

		<h2>Data</h2>

		<p>
			The default return value that <code>`getInitialState`</code> expects is an object representing the initial state of the component; However <code>`getInitialState`</code> also accepts a <code>`Promise`</code> when the data requirements are network bound <label for=2></label>.
			<span class=note>That is to say you can asynchronous-ly retrieve a components initial state.</span>
		</p>

<pre><code>
class Welcome {
	getInitialState() {}
	render() {}
}
</code></pre>

		<h2 id=refs>Refs</h2>

		<p>Refs are either functions of strings that provide access to the underlining DOM an element or Instance of a component.</p>

<pre><code>
class Welcome {
	retrieveDOM(el) {
		console.log(el.getBoundingClientRect())
	}
	render() {
		return h('h1', {
			ref: this.retrieveDOM
		}, 'Welcome')
	}
}
</code></pre>

		<h2 id=mounting>Mounting</h2>

		<p>Mounting happens in a bottom-up fashion in that the lifecycle method of child components will be invoked before the parent.</p>

		<p>The lifecycle method <code>`componentDidMount`</code> receive the mounting DOM node as an argument.</p>

<pre><code>
class Welcome {
	componentWillMount() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentDidMount() {}
}
</code></pre>

		<h2 id=updating>Updating</h2>

		<p>Certain lifecycles are only invoked in the update phase; When an update is triggerd through <code>`this.setState`</code> or <code>`this.forceUpdate`</code> the <code>`componentWillReceiveProps`</code> lifecycle will not be invoked because new props are not received.</p>

		<p>On the other hand if <code>`shouldComponentUpdate`</code> returns <code>false</code> then a component will skip that specific update phase.</p>

<pre><code>
class Welcome {
	componentWillReceiveProps() {}
}
</code></pre>

<pre><code>
class Welcome {
	shouldComponentUpdate() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentWillUpdate() {}
}
</code></pre>

<pre><code>
class Welcome {
	componentDidUpdate() {}
}
</code></pre>

		<h2 id=unmounting>Umounting</h2>

		<p>Unlike mounting Unmounting happens in a top-down fashion, the lifecycle method <code>`componentWillUnmount`</code> is unique in that it is the only lifecycle method that cannot update state because at this phase the component is due to be removed from the DOM.</p>

		<p>On the other hand <code>`componentWillUnmount`</code> can return a <code>Promise</code>; When used the unmounting DOM node will be removed once the <code>Promise</code> resolves.</p>

		<p>Like <code>componentDidMount</code>, <code>`componentWillUnmount`</code> also recieves the unmounting DOM node as an argument.</p>

<pre><code>
class Welcome {
	componentWillUnmount() {}
}
</code></pre>

		<h1 id=setstate>setState</h1>

		<p>A component can update its state by invoking <code>`this.setState`</code> with an Object representing how to update the state or a <code>`Promise`</code> that resolves to a similar Object.</p>

		<p>In addition you could optionaly update the state by returning an Object/Promise from a lifcycle method or event handler; </p>

		<p>For example:</p>

		<h2>Data</h2>

<pre><code>
class Welcome {
	getInitialState() {
		return {n: 0}
	}
}
</code></pre>

		<h2>Lifecycle</h2>

<pre><code>
class Welcome {
	componentDidMount() {
		return {n: 0}
	}
}
</code></pre>

		<h2>Event</h2>

<pre><code>
class Welcome {
	handleClick() {
		return {n: 0}
	}
	render() {
		h('button', {
			onclick: this.handleClick
		}, 'Click Me')
	}
}
</code></pre>

		<h2>Async</h2>

<pre><code>
class Welcome {
	async getInitialState() {
		return {n: 0}
	}
}
</code></pre>

		<h1 id=setstate>forceUpdate</h1>

		<p>Used when you want to invoke an update without a state update, <code>`this.forceUpdate`</code>.</p>

		<h1 id=render>Render</h1>

		<p>
		The first argument is the virtual element <label for=4></label>
		<span class=note>This includes strings, numbers, functions, null, and virtual elements.</span>
		you want to render, the second is the root DOM node you want render to. There is an optional third argument that doubles as a callback function when a function is passed or a server-side rendered node for hydration.
		</p>

<pre><code>
dio.render('Hello World', document.body)
</code></pre>

		<p>When ommitted, the root DOM node defaults to the <code>`&lt;body>`</code> or <code>`&lt;html>`</code> DOM nodes.</p>

		<pre><code>
		dio.render('Hello World')
		</code></pre>

		<p>By default calling <code>`render`</code> when mounting preserves the children of the mount node you specifiy; This means that you can mount to <code>`document.body`</code> without any side-effects.</p>

		<p></p>

		<h2 id=server>Server</h2>

		<p>The recommended way to render from the server is to use <code>`dio.renderToStream`</code> or <code>`dio.renderToString`</code> which can also render to a writable stream.</p>

<pre><code>
const http = require('http')
const dio = require('dio.js')

const webpage = (
	h('!doctype',
  	h('head',
  		h('title', 'Title!'),
  		h('style', `h1 {color:red;}`),
  		h('script', `console.log("Hello")`)
  	),
  	h('body', 'Hello World')
	)
)

const server = (request, response) => {
	dio.renderToStream(webpage, response, () => console.log('callback'))
}

http.createServer(server).listen(2000)
</code></pre>

		<p>By design using <code>`dio.renderToStream`</code> to render on the server uses a stream to send the response to the client in chunks, on the other hand <code>`dio.renderToString`</code> and the <code>`toString`</code> method on virtual elements returns the element as a string. Which allows us to render a string in the following ways.</p>

<pre><code>
dio.renderToString(h('html')) === `${h('html')}` === `&lt;html>&lt;/html>`
</code></pre>

		<h2 id=testing>toJSON</h2>

		<p>All elements on the server have a `toJSON` method that returns a flat element representation, that can be used for testing.</p>

<pre><code>
h('html').toJSON()
</code></pre>

		<h1 id=version>Version</h1>

		<p>Retrieves the current version of DIO in use, ex. <code>`8.0.0`</code></p>

<pre><code>
console.log(dio.version)
</code></pre>

		<h1 id=other>Other</h1>

		<h2 id=statics>Static defaultProps</h2>

		<p>The following would resemble attaching the returned object of the functions to the <code>`Welcome` class</code>.</p>

<pre><code>
class Welcome {
	static defaultProps () {
		return {id: 1}
	}
	render () {

	}
}
</code></pre>

		<h2 id=error-boundaries>Error Boundary</h2>

		<p>
			All components have a default error boundary that cascades to the nearest parent component if the component does not define
			a `componentDidCatch` method.
		</p>
<pre><code>
class Welcome {
	componentDidThrow({from, message, children, stack}) {
		if (from === 'render')
			return h('h1', 'Error State for render Error')
		else
			return h('h1', 'Error State for another Error')
	}
	render () {
		throw ''
	}
}
</code></pre>

		<p>Pseudo Code:</p>

		<ol>
			<li>We create a components that intentionally throws in the render phase.</li>
			<li>DIO catches this and passes it to the <code>`componentDidCatch`</code> method if it exists.</li>
			<li>Our <code>`componentDidCatch`</code> method detects if the error comes from <code>`render`</code> and responds with an error state.</li>
		</ol>

		<p>On the other hand if the error happend in the update phase and we did not handle it, DIO would simply resolve to the nearest parent component that defines `componentDidCatch`. If does not exist a component in the render tree that defines a `componentDidCatch` error state, DIO will unmount all component from the root.</p>

		<h2 id=non-deterministic>Non-Deterministic</h2>

		<p>
			By default rendering something is a <a href=https://en.wikipedia.org/wiki/Deterministic_system>deterministic</a> <label for=5></label><span class=note>A deterministic system is a system in which no randomness is involved in the development of future states of the system.</span> operation,
			given the following children <code>`[A, B, C, D]`</code> the path the flow would take would be.
		</p>

		<p class=math>A &#x2192; B &#x2192; C &#x2192; D</p>

		<p>
			But <a href=https://en.wikipedia.org/wiki/Nondeterministic_algorithm>non-deterministic</a> <label for=6></label>
			<span class=note>A non-deterministic algorithm is an algorithm that, even for the same input, can exhibit different behaviors on different runs.</span>
			introduces the aspect of non-linear updates, where instead of <code>`A &#x2192; B &#x2192; C &#x2192; D`</code> you could get an array of different update sequences;
		</p>

		<p>For example:</p>

		<p class=math>C &#x2192; D &#x2192; A &#x2192; B</p>

		<p>This is possible because DIO can pause and resume an update to a specific component depending on how long we tell it to wait before following through.</p>

		<p>In the example that follows we wait for a random time before resolving the return value of a render.</p>

<pre><code>
class Welcome {
	render() {
		return new Promise((resolve) => {
			setTimeout(() => {
				resolve(
					h('h1',
						'performance now - ',
						performance.now()
					)
				)
			}, Math.random()*1000)
		})
	}
}
</code></pre>

		<p>Putting multiple instances of this component in a list will result in a random update order whenever an update is invoked.</p>

		<h2 id=coroutine>Iterables</h2>

		<p>DIO supports render any `Iterables` including `Generators`.</p>

<pre><code>
class Generator {
	*render(props, state) {
		let supply = 0

		while (supply < 10) {
			yield h('button', {
				onclick: this.forceUpdate
			}, 'Click Me - ', supply++)
		}
	}
}
</code></pre>

		<h2 id=animations>Animations</h2>

		<p>There is no specialized API for animations in DIO, however the mount/unmount lifecycles methods have been designed with animations in mind.</p>

		<p>Making use of the <code>`componentWillUnmount`</code> lifecycle return signature and <code>`componentDidMount`</code> we can animate any component; For example, using the new <a href=https://developer.mozilla.org/en-US/docs/Web/API/Element/animate>Element.animate</a><label for=8></label><span class=note>The Web Animations API opens the browser’s animation engine to developers and manipulation by JavaScript. This API was designed to underlie implementations of both CSS Animations and CSS Transitions, and leaves the door open to future animation effects. It is one of the most performant ways to animate on the Web where supported, letting the browser make its own internal optimizations without hacks, coercion, or Window.requestAnimationFrame(). <a href=https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API/Using_the_Web_Animations_API>Using the Web Animations API.</a></span> API:</p>

<pre><code>
const animations = {
	fadeOut: [
	  {transform: 'translateY(0)', opacity: 1},
  	{transform: 'translateY(-100%)', opacity: 0}
  ],
  fadeIn: [
	  {transform: 'translateY(-100%)', opacity: 0},
  	{transform: 'translateY(0%)', opacity: 1}
  ]
}

class Item {
	componentDidMount(node) {
		node.animate(animations.fadeIn, {
			duration: 200
		});
	}
	componentWillUnmount(node) {
		return new Promise((resolve) => {
			node.animate(animations.fadeOut, {
				duration: 200
			}).onfinish = resolve
		})
	}
	render() {
		return h('li', this.props.children)
	}
}

class List {
	render() {
		return h('ul', this.props.children.map(
			v => h(List, v)
		))
	}
}

dio.render(h(List, 1, 2, 3))

setTimeout(dio.render, 400, h(List, 1, 2, 3, 4))
setTimeout(dio.render, 800, h(List, 1, 2, 3))
</code></pre>
		<p>Pseudo Code:</p>

		<ol>
			<li>We create <code>`Item`</code> component that triggers a <code>fadeIn</code> animation when mounted and <code>fadeOut</code> when unmounted.</li>
			<li>We create multiple instances of the <code>`Item`</code> component in our <code>`List`</code> component.</li>
			<li>We then render our <code>`List`</code> component with children <code>[1, 2, 3]</code>.</li>
			<li>Three <code>`List`</code> components mount and animate when <code>`componentDidMount`</code> is invoked.</li>
			<li>After <code>`400ms`</code> we update our <code>`List`</code> components children &mdash; <br> <code>[1, 2, 3, 4]</code>.</li>
			<li>This mounts a new instance of our <code>`Item`</code> component.</li>
			<li>After <code>`800ms`</code> we remove one <code>`Item`</code> child from our <code>`List`</code> component, which in turn invokes our <code>fadeOut</code> animation in <code>`componentWillUnmount`</code>.</li>
		</ol>

		<h2 id=promises>Promises</h2>

		<p>In large applications, bundles might become too big to send to the client in one chunk, this suggests the need to divide the app into smaller chunks and only load a component from the server when it is actually needed.</p>

		<p>To make this task easier DIO allows a <code>Promise</code> return type from Components that you can use to control when a component renders, essentially baking the  
		<a href="https://en.wikipedia.org/wiki/Lazy_loading">"Lazy loading"</a><label for=9></label><span class="note">Lazy loading is a design pattern commonly used in computer programming to defer initialization of an object until the point at which it is needed. It can contribute to efficiency in the program's operation if properly and appropriately used.</span> design pattern into the component model.
		</p>

		<p>
			However when talking about lazy loading, we have to consider what we want to display while we wait for the network to resolve.
			In this case DIO supports an optional children to define what component will show while waiting for the network.
		</p>

<pre><code>
class Welcome {
	render() {
		return h(import('./welcome.js'), h('h1', 'Loading'))
	}
}		
</code></pre>

		<p>As demonstrated above this allows us to lazy load components when we need them and what to display before the requested module has been resolved.</p>

	</article>
	<script src=js/highlight.js></script>
	<script src=js/main.js></script>
</body>
</html>
